
function! OpenTrelloCard()
  let a:line = getline('.')
  if match(a:line, "^\* <.*>") != -1
    let a:link = substitute(a:line, '^.*<\([^>]*\)>.*$', '\1', 'g')
    call system ('browser_open_url -f "https://trello.com/c/' . a:link . '"')
  elseif match(a:line, "^# <.*>") != -1
    let a:link = substitute(a:line, '^.*<\([^>]*\)>.*$', '\1', 'g')
    call system ('browser_open_url -f "https://trello.com/b/' . a:link . '"')
  endif
endfunction

function! AddTrelloCard()
  let a:line = getline('.')
  if match(a:line, "^## <[^>]*>") != -1
    let a:link = substitute(a:line, '^## <\([^>]*\)>.*$', '\1', 'g')
    silent ! pass foo/foo
    execute('silent !clear;clitrello add_card ' . a:link)
    execute('redraw!')
  endif
endfunction

function! ArchiveTrelloCard()
  let a:line = getline('.')
  if match(a:line, "^\* <[^>]*>") != -1
    let a:link = substitute(a:line, '^\* <\([^>]*\)>.*$', '\1', 'g')
    silent ! pass foo/foo
    execute('silent !clear;clitrello archive_card ' . a:link)
    execute('redraw!')
  endif
endfunction

function! RenameTrelloCard()
  let a:line = getline('.')
  if match(a:line, "^\* <[^>]*>") != -1
    let a:link = substitute(a:line, '^\* <\([^>]*\)>.*$', '\1', 'g')
    let a:old_name = substitute(a:line, '^\* <\([^>]*\)>[^`]*`\([^`]*\)`$', '\2', 'g')
    silent ! pass foo/foo
    execute('silent !clear; old_name="' . a:old_name . '" clitrello rename_card ' . a:link)
    execute('redraw!')
  endif
endfunction

function! OpenTrelloBoard()
  let a:line = getline('.')
  if match(a:line, "^# <[^>]*>") != -1
    let a:link = substitute(a:line, '^# <\([^>]*\)>.*$', '\1', 'g')
    silent ! pass foo/foo
    execute('%! clitrello board_by_id_cards ' . a:link . ' cards_group_by_board cards_grouped_to_markdown')
    set filetype=markdown
    execute('redraw!')
  endif
endfunction

function! OpenTrelloListHistory()
  let a:line = getline('.')
  if match(a:line, "^## <[^>]*>") != -1
    let a:link = substitute(a:line, '## <\([^>]*\)>.*$', '\1', 'g')
    silent ! pass foo/foo
    execute('%! custom_markdown_fields="+ (.dateLastActivity|sub(\"T.*$\";\" \"))" clitrello list_closed_cards ' . a:link . ' cards_idmembers_to_members cards_group_by_board cards_grouped_to_markdown')
    set filetype=markdown
    execute('redraw!')
  endif
endfunction

function! OpenTrelloAllBoards()
  silent ! pass foo/foo
  execute('%! clitrello boards_by_member boards_to_markdown')
  set filetype=markdown
  execute('redraw!')
endfunction

function! UpdateBuffer()
  let a:line = getline(1)
  if match(a:line, "^# <[^>]*>") != -1
    let a:link = substitute(a:line, '^# <\([^>]*\)>.*$', '\1', 'g')
    if a:link == "my_cards"
      call ReadMyCards()
    else
      let save_pos = getpos(".")
      silent ! pass foo/foo
      execute('%! clitrello board_by_id_cards ' . a:link . ' cards_group_by_board cards_grouped_to_markdown')
      call setpos('.', save_pos)
      set filetype=markdown
      execute('redraw!')
      unlet save_pos
    endif
  endif
endfunction


" This callback will be executed when the entire command is completed
function! BackgroundCommandClose(channel)
  let save_pos = getpos(".")
  execute '%! cat ' . g:backgroundCommandOutput
  call setpos('.', save_pos)
  execute('redraw!')
  execute('set filetype=markdown')
  unlet save_pos
  unlet g:backgroundCommandOutput
endfunction

function! RunBackgroundCommand(command)
  " Make sure we're running VIM version 8 or higher.
  if v:version < 800
    " run task sync
    let g:save_pos = getpos(".")
    % ! clitrello cards_by_member cards_filter_hidden cards_group_by_board  cards_grouped_clear_empty_lists cards_grouped_to_markdown
    call setpos('.', save_pos)
    " echoerr 'RunBackgroundCommand requires VIM version 8 or higher'
    return
  endif

  if exists('g:backgroundCommandOutput')
    echo 'Already running task in background'
  else
    echo 'Running task in background'
    " Launch the job.
    " Notice that we're only capturing out, and not err here. This is because, for some reason, the callback
    " will not actually get hit if we write err out to the same file. Not sure if I'm doing this wrong or?
    let g:backgroundCommandOutput = tempname()
    call job_start(a:command, {'close_cb': 'BackgroundCommandClose', 'out_io': 'file', 'out_name': g:backgroundCommandOutput})
  endif
endfunction

function! ReadMyCards()
  silent ! pass foo/foo
  execute('redraw!')
  call RunBackgroundCommand("clitrello cards_by_member cards_filter_hidden cards_group_by_board  cards_grouped_clear_empty_lists cards_grouped_to_markdown")
endfunction

nnoremap <Leader>u :call UpdateBuffer()<CR>
nnoremap <Leader>e :call RenameTrelloCard()<CR>
nnoremap <Leader>c :call ArchiveTrelloCard()<CR>
nnoremap <Leader>a :call AddTrelloCard()<CR>

nnoremap <Leader>k :call ReadMyCards()<CR>
nnoremap <Leader>h :call OpenTrelloListHistory()<CR>
nnoremap <Leader>L :call OpenTrelloCard()<CR>
nnoremap <Leader>l :call OpenTrelloBoard()<CR>
nnoremap <Leader>m :call OpenTrelloAllBoards()<CR>

set filetype=markdown

if ! empty($custom_vimrc)
  let g:custom_vimrc=$custom_vimrc
  nnoremap <Leader>r :exec('source ' . g:custom_vimrc)<CR>
endif

